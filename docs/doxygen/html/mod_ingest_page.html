<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Developing Ingest Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Autopsy Forensic Browser Developer&#39;s Guide and API Reference</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Developing Ingest Modules </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ingest_modules_getting_started"></a>
Getting Started</h1>
<p>This page describes how to develop ingest modules using either Java or Python (Jython). It assumes you have already set up your development environment as described in <a class="el" href="mod_dev_page.html">Java Development Setup</a> or <a class="el" href="mod_dev_py_page.html">Python Development Setup</a>.</p>
<h1><a class="anchor" id="ingest_module_types"></a>
Ingest Module Types</h1>
<p>Ingest modules analyze data from a data source (e.g., a disk image or a folder of logical files). There are two types of ingest modules in Autopsy:</p>
<ul>
<li>Data-source-level ingest modules</li>
<li>File-level ingest modules</li>
</ul>
<p>The difference between these two types of modules is what gets passed in to them:</p><ul>
<li>Data source-level ingest modules get passed in a reference to a data source and it is up to the module to search for the files that it wants to analyze.</li>
<li>File-level ingest modules are passed in a reference to each file, one at a time, and it analyzes the file that gets passed in.</li>
</ul>
<p>Here are some guidelines for choosing the type of your ingest module:</p>
<ul>
<li>Your module should be a data-source-level ingest module only if the following are true:<ul>
<li>It needs to retrieve and analyze only a small number of files.</li>
<li>It can find the files by name or other metadata in the database.</li>
<li>It does not depend on results from other file-level ingest modules.</li>
<li>It does not need access to the contents of ZIP and other archive files. For example, our Windows registry analysis is done as a data source-level ingest module because it can query for the registry hives and process the small number of files that are found.</li>
</ul>
</li>
<li>If your needs are not met by a data source-level ingest module, then it should be a file-level ingest module.</li>
</ul>
<p>As you will learn a little later in this guide, it is possible to make an ingest module that has both file-level and data-source level capabilities. You would do this when you need to work at both levels to get all of your analysis done. The modules in such a pair will be enabled or disabled together and will have common per ingest job and global settings.</p>
<p>The text below will refer to example code in the org.sleuthkit.autopsy.examples package. The sample modules don't do anything particularly useful, but they can serve as templates for developing your own ingest modules.</p>
<h1><a class="anchor" id="ingest_modules_lifecycle"></a>
Ingest Module Life Cycle</h1>
<p>Before we dive into the details of creating a module, it is important to understand the life cycle of the module. Note that this life cycle is much different for Autopsy 3.1 and newer modules compared to Autopsy 3.0 modules. This section only talks about 3.1 and newer modules.</p>
<p>You will need to implement at least two classes to make an ingest module:</p><ol type="1">
<li>A factory class that will be created when Autopsy starts and will provide configuration panels to Autopsy and will create instances of your ingest module.</li>
<li>An ingest module class that will be instantiated by the factory when the ingest modules are run. A new instance of this class will be created for each ingest thread.</li>
</ol>
<p>Here is an example sequence of events. Details will be provided below.</p><ol type="1">
<li>User launches Autopsy and it looks for classes that implement the org.sleuthkit.autopsy.ingest.IngestModuleFactory interface.</li>
<li>Autopsy finds and creates an instance of your FooIngestModuleFactory class.</li>
<li>User adds a disk image.</li>
<li>Autopsy presents the list of available ingest modules to the user and uses the utility methods from FooIngestModuleFactory class to get the module's name, description, and configuration panels.</li>
<li>User enables your module (and others).</li>
<li>Autopsy uses FooIngestModuleFactory to create two instances of FooIngestModule (Autopsy is using two threads to process the files).</li>
<li>Autopsy calls FooIngestModule.startUp() on each thread and then calls FooIngestModule.process() to pass in each file.</li>
</ol>
<h1><a class="anchor" id="ingest_modules_implementing_ingestmodulefactory_basic"></a>
Creating a Basic Ingest Module</h1>
<h2><a class="anchor" id="ingest_modules_implementing_basic_factory"></a>
Basic Ingest Module Factory</h2>
<p>The first step to write an ingest module is to make its factory. There are three general types of things that a factory does:</p><ol type="1">
<li>Provides basic information such as the module's name, version, and description. (required)</li>
<li>Creates ingest modules. (required)</li>
<li>Provides panels so that the user can configure the module. (optional)</li>
</ol>
<p>This section covers the required parts of a basic factory so that we can make the ingest module. A later section (<a class="el" href="mod_ingest_page.html#ingest_modules_making_options">User Options and Configuration</a>) covers how you can use the factory to provide options to the user.</p>
<p>To make writing a simple factory easier, Autopsy provides an adapter class that implements the "optional" methods in the interface. Our basic factory will use the adapter.</p>
<ol type="1">
<li>Make a factory class by either:<ul>
<li>Copy and pasting the sample code from org.sleuthkit.autopsy.examples.SampleIngestModuleFactory (Java) or org.sleuthkit.autopsy.examples.ingestmodule.py.</li>
<li>Manually define a new class that extends (Java) or inherits (Jython) org.sleuthkit.autopsy.ingest.IngestModuleFactoryAdapter. If you are using Java, NetBeans will likely complain that you have not implemented the necessary methods and you can use its "hints" to automatically generate stubs for them.</li>
</ul>
</li>
<li>Update and create the needed methods using the org.sleuthkit.autopsy.ingest.IngestModuleFactory interface documentation. You can also use the sample code mentioned above for examples of what the methods should do if you did not already copy and paste them.</li>
<li>If you are using Java, import org.openide.util.lookup.ServiceProvider and add a dependency on the NetBeans Lookup API module to the NetBeans module that contains your ingest module. Then add a NetBeans ServiceProvider annotation so that the factory is found at run time: <div class="fragment"><div class="line">@ServiceProvider(service = IngestModuleFactory.class)</div></div><!-- fragment --></li>
</ol>
<p>At this point, when you add a data source to an Autopsy case, you should see the module in the list of ingest modules. If you don't see it, double check that you either implemented org.sleuthkit.autopsy.ingest.IngestModuleFactory or extended or inherited org.sleuthkit.autopsy.ingest.IngestModuleFactoryAdapter. If using Java, make sure that you added the service provider annotation.</p>
<h2><a class="anchor" id="ingest_modules_implementing_ingestmodule"></a>
Common Concepts of Ingest Modules</h2>
<p>Before we cover the specific interfaces of the two different types of modules, let's talk about some common things.</p><ul>
<li>They both have a startUp() method and the expectation is that if there is any error in setting up the module, then they will throw an exception from this method so that ingest can be immediately stopped before analysis begins and the user can fix the problem.</li>
<li>Autopsy will call a module from only a single thread. It may make several threads, but it will make an instance of the module for each thread. You do not need to worry about thread safety unless you are using static variables or other kinds of variables that would be shared among multiple instances of the module.</li>
</ul>
<h2><a class="anchor" id="ingest_modules_implementing_datasourceingestmodule"></a>
Creating a Data Source-level Ingest Module</h2>
<p>To create a data source ingest module:</p><ol type="1">
<li>Create the ingest module class by either:<ul>
<li>Copy and paste the sample modules from:<ul>
<li>Java: Core/src/org/sleuthkit/autopsy/examples/SampleDataSourceIngestModule.java</li>
<li>Python: pythonExamples/dataSourceIngestModule.py (<a href="https://github.com/sleuthkit/autopsy/tree/develop/pythonExamples">https://github.com/sleuthkit/autopsy/tree/develop/pythonExamples</a>)</li>
</ul>
</li>
<li>Or the manual approach is to define a new class that implements (Java) or inherits (Jython) org.sleuthkit.autopsy.ingest.DataSourceIngestModule. If you are using Java, the NetBeans IDE will complain that you have not implemented one or more of the required methods. You can use its "hints" to automatically generate stubs for the missing methods.</li>
</ul>
</li>
<li>Configure your factory class to create instances of the new ingest module class. To do this, you will need to change the isDataSourceIngestModuleFactory() method to return true and have the createDataSourceIngestModule() method return a new instance of your ingest module. Both of these methods have default "no-op" implementations in the IngestModuleFactoryAdapter that we used. Your factory should have code similar to this Java code:</li>
</ol>
<div class="fragment"><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keywordtype">boolean</span> isDataSourceIngestModuleFactory() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> DataSourceIngestModule createDataSourceIngestModule(IngestModuleIngestJobSettings ingestOptions) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> FooDataSourceIngestModule();  <span class="comment">// replace this class name with the name of your class</span></div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li>Use this page, the sample, and the documentation for the org.sleuthkit.autopsy.ingest.DataSourceIngestModule interfaces to implement the startUp() and process() methods.<ul>
<li>org.sleuthkit.autopsy.ingest.DataSourceIngestModule.startUp() is where any initialiation occurs. If your module has a critical failure and will not be able to run, your startUp method should throw an IngestModuleException to stop ingest.</li>
<li>org.sleuthkit.autopsy.ingest.DataSourceIngestModule.process() is where all of the work of a data source ingest module is done. It will be called exactly once. The process() method receives a reference to an org.sleuthkit.datamodel.Content object and an org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress object. The former is a representation of the data source. The latter should be used by the module instance to report progress as it does its potentially long-running processing. To be a good citizen within Autopsy, the module should also periodically call org.sleuthkit.autopsy.ingest.IngestJobContext.isJobCancelled() and break off processing if the ingest is canceled.</li>
</ul>
</li>
</ol>
<p>Note that data source ingest modules must find the files that they want to analyze. The best way to do that is using one of the findFiles() methods of the org.sleuthkit.autopsy.casemodule.services.FileManager class. See <a class="el" href="platform_page.html#mod_dev_other_services">Framework Services and Utilities</a> for more details.</p>
<h2><a class="anchor" id="ingest_modules_implementing_fileingestmodule"></a>
Creating a File Ingest Module</h2>
<p>To create a file ingest module: To create a data source ingest module:</p><ol type="1">
<li>Create the ingest module class by either:<ul>
<li>Copy and paste the sample modules from:<ul>
<li>Java: Core/src/org/sleuthkit/autopsy/examples/SampleFileIngestModule.java</li>
<li>Python: pythonExamples/fileIngestModule.py (<a href="https://github.com/sleuthkit/autopsy/tree/develop/pythonExamples">https://github.com/sleuthkit/autopsy/tree/develop/pythonExamples</a>)</li>
</ul>
</li>
<li>Or the manual approach is to define a new class that implements (Java) or inherits (Jython) org.sleuthkit.autopsy.ingest.FileIngestModule. If you are using Java, the NetBeans IDE will complain that you have not implemented one or more of the required methods. You can use its "hints" to automatically generate stubs for the missing methods.</li>
</ul>
</li>
<li>Configure your factory class to create instances of the new ingest module class. To do this, you will need to change the isFileIngestModuleFactory() method to return true and have the createFileIngestModule() method return a new instance of your ingest module. Both of these methods have default "no-op" implementations in the IngestModuleFactoryAdapter that we used. Your factory should have code similar to this Java code:</li>
</ol>
<div class="fragment"><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keywordtype">boolean</span> isFileIngestModuleFactory() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> FileIngestModule createFileIngestModule(IngestModuleIngestJobSettings ingestOptions) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> FooFileIngestModule(); <span class="comment">// replace this class name with the name of your class</span></div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li>Use this page, the sample, and the documentation for the org.sleuthkit.autopsy.ingest.FileIngestModule interface to implement the startUp(), and process(), and shutDown() methods.<ul>
<li>org.sleuthkit.autopsy.ingest.FileIngestModule.startUp() should have any code that you need to initialize your module. If you have any startup errors, be sure to throw a IngestModuleException exception to stop ingest.</li>
<li>org.sleuthkit.autopsy.ingest.FileIngestModule.process() is where all of the work of a file ingest module is done. It will be called repeatedly between startUp() and shutDown(), once for each file Autopsy feeds into the pipeline of which the module instance is a part. The process() method receives a reference to a org.sleuthkit.datamodel.AbstractFile object.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="ingest_modules_implementing_next"></a>
Next Steps</h2>
<p>This section gave you the outline of making the module. Now we'll cover what you can do in the module. The following sections often make use of the org.sleuthkit.autopsy.ingest.IngestServices class, which provides many convenient services to make module writing easier. Also make sure you refer to <a class="el" href="platform_page.html#mod_dev_other_services">Framework Services and Utilities</a> if you are looking for a feature.</p>
<h1><a class="anchor" id="ingest_modules_making_results"></a>
Doing Something With Your Results</h1>
<p>The previous section outlined how to make the basic module and how to get access to the data. The next step is to then do some fancy analysis and present the results to the user.</p>
<p>The first question that you must answer is what type of data do you want the user to see. There are two options:</p>
<ol type="1">
<li>Data that can be accessed from the tree on the left-hand side of the UI and can be displayed in a table. To do this, you will make blackboard artifacts.</li>
<li>Data that is in a big text file or some other report that the user can review. To do this, you will use the Case.addReport() method to make the output available in the directory tree.</li>
</ol>
<h2><a class="anchor" id="ingest_modules_making_results_bb"></a>
Posting Results to the Blackboard</h2>
<p>The blackboard is used to store results so that they are displayed in the results tree. See <a class="el" href="platform_page.html#platform_blackboard">The Blackboard</a> for details on posting results to it. You use the blackboard when you have specific items to show the user. if you want to just shown them a big report from another library or tool, see <a class="el" href="mod_report_page.html">Developing Report Modules</a>. The blackboard defines artifacts for specific data types (such as web bookmarks). You can use one of the standard artifact types or create your own.</p>
<p>When modules add data to the blackboard, they should notify listeners of the new data by invoking the org.sleuthkit.autopsy.ingest.IngestServices.fireModuleDataEvent() method. Do so as soon as you have added an artifact to the blackboard. This allows other modules (and the main UI) to know when to query the blackboard for the latest data. However, if you are writing a large number of blackboard artifacts in a loop, it is better to invoke org.sleuthkit.autopsy.ingest.IngestServices.fireModuleDataEvent() only once after the bulk write, so as not to flood the system with events.</p>
<p>Further, when modules create artifacts, they should be indexed for keyword search, using the method Blackboard.indexArtifact(BlackboardArtifact artifact). This can be done in the following way:</p>
<div class="fragment"><div class="line">Blackboard blackboard = Case.getCurrentCase().getServices().getBlackboard();</div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    blackboard.indexArtifact(artifact); <span class="comment">//Your artifact as the parameter.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (BlackboardException ex) {</div><div class="line">    <span class="comment">//YOUR EXCEPTION BEHAVIOR HERE.</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ingest_modules_making_results_report"></a>
Making a Report</h2>
<p>If your module makes a text or HTML file (or some other report format) that has some complex structure (either because you prefer to write output that way or your module is simply a wrapper around another tool), then you can simply call the output a report and then it will be shown in the UI in the reports area. You can do this by calling the org.sleuthkit.autopsy.casemodule.Case.addReport() method.</p>
<h1><a class="anchor" id="ingest_modules_users"></a>
Getting User Attention</h1>
<p>The ingest modules are running in the background and the user will not notice everything you put in the tree.</p>
<h2><a class="anchor" id="ingest_modules_making_results_inbox"></a>
Posting Results to the Message Inbox</h2>
<p>Modules should post messages to the inbox when interesting data is found. Of course, such data should also be posted to the blackboard as described above. The idea behind the ingest messages is that they are presented in chronological order so that users can see what was found while they were focusing on something else.</p>
<p>Inbox messages should only be sent if the result has a low false positive rate and will likely be relevant. For example, the core Autopsy hash lookup module sends messages if known bad (notable) files are found, but not if known good (NSRL) files are found. This module also provides a global setting (using its global settings panel) that allows a user to turn these messages on or off.</p>
<p>Messages are created using the org.sleuthkit.autopsy.ingest.IngestMessage class and posted to the inbox using the org.sleuthkit.autopsy.ingest.IngestServices.postMessage() method.</p>
<h2><a class="anchor" id="ingest_modules_making_results_error"></a>
Reporting Errors</h2>
<p>When an error occurs, you should write an error message to the Autopsy logs, using a logger obtained from org.sleuthkit.autopsy.ingest.IngestServices.getLogger().</p>
<p>You could also send an error message to the ingest inbox. The downside of this is that the ingest inbox was not really designed for this purpose and it is easy for the user to miss these messages. Therefore, it is preferable to post a pop-up message that is displayed in the lower right hand corner of the main window by calling org.sleuthkit.autopsy.coreutils.MessageNotifyUtil.Notify.show().</p>
<h1><a class="anchor" id="ingest_modules_making_options"></a>
User Options and Configuration</h1>
<p>Autopsy allows a module to provide two levels of configuration:</p><ul>
<li>When an ingest job is being configured, the user can choose settings that are unique to that ingest job / pipeline. For example, to enable a certain hash set.</li>
<li>The user can configure global settings that apply to all jobs. For example, to add or delete a hash set.</li>
</ul>
<p>To provide either or both of these options to the user, we need to implement methods defined in the IngestModuleFactory interface. You can either add them to your class that extends the IngestModuleFactoryAdapter or decide to simply implement the interface.</p>
<p>You can also refer to sample implementations of the interfaces and abstract classes in the org.sleuthkit.autopsy.examples package, although you should note that the samples do not do anything particularly useful.</p>
<h2><a class="anchor" id="ingest_modules_making_options_ingest"></a>
Ingest Job Options</h2>
<p>Autopsy allows you to provide a graphical panel that will be displayed when the user decides to enable the ingest module. This panel is supposed to be for settings that the user may turn on or off for different data sources.</p>
<p>To provide options for each ingest job:</p><ul>
<li>Update org.sleuthkit.autopsy.ingest.IngestModuleFactory.hasIngestJobSettingsPanel() in your factory class to return true.</li>
<li>Update org.sleuthkit.autopsy.ingest.IngestModuleFactory.getIngestJobSettingsPanel() in your factory class to return a IngestModuleIngestJobSettingsPanel that displays the needed configuration options. The recommended size for this panel is 300 x 300. The org.sleuthkit.autopsy.ingest.IngestModuleIngestJobSettingsPanel.getSettings() method should return an instance of a org.sleutkit.autopsy.ingest.IngestModuleIngestJobSettings object based on the user-specified settings (see next bullet).</li>
<li>Create a class that implements org.sleutkit.autopsy.ingest.IngestModuleIngestJobSettings. Your IngestModuleIngestJobSettingsPanel should store settings in here. This class needs to be Serializable, so keep all data types simple or mark them as transient with some custom deserialization code. You should also set the serialVersionUID (see <a href="http://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it">http://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it</a>).</li>
<li>If you decide to store settings internal to the module (NOT RECOMMENDED), the getSettings() method can return an instance of NoIngestModuleIngestJobSettings.</li>
<li>Your instance of IngestModuleIngestJobSettings will be saved and passed to your panel the next time so that you can pre-populate it accordingly.</li>
</ul>
<p>Your panel should create the IngestModuleIngestJobSettings class to store the settings and that will be passed back into your factory with each call to createDataSourceIngestModule() or createFileIngestModule(). The way that we have implemented this in Autopsy modules is that the factory casts the IngestModuleINgestJobSettings object to the module-specific implementation and then passes it into the constructor of the ingest module. The ingest module can then call whatever getter methods that were defined based on the panel settings.</p>
<p>You can also implement the getDefaultIngestJobSettings() method to return an instance of your IngestModuleIngestJobSettings class with default settings. Autopsy will call this when the module has not been run before.</p>
<p>NOTE: We recommend storing simple data in the IngestModuleIngestJobSettings-based class. In the case of our hash lookup module, we store the string names of the hash databases to do lookups in. We then get the hash database handles in the call to startUp() using the global module settings.</p>
<p>NOTE: The main benefit of using the IngestModuleIngestJobSettings-based class to store settings (versus some static variables in your package) are:</p><ul>
<li>When multiple jobs are running at the same time, each can have their own settings.</li>
<li>Autopsy persists them so that the last used settings get passed into the call to getIngestJobSettingsPanel() and you don't need to save them yoursevles to provide the user the benefit of re-using the last settings.</li>
</ul>
<h2><a class="anchor" id="ingest_modules_making_options_global"></a>
Global Options</h2>
<p>Global options are those that are not specific to a data source or ingest pipeline. They are big-picture settings.</p>
<p>To provide global options:</p><ul>
<li>Update org.sleuthkit.autopsy.ingest.IngestModuleFactory.hasGlobalSettingsPanel() in your factory class to return true.</li>
<li>Update org.sleuthkit.autopsy.ingest.IngestModuleFactory.getGlobalSettingsPanel() to return a org.sleuthkit.autopsy.ingest.IngestModuleGlobalSetttingsPanel with widgets to support the global settings.</li>
<li>You are responsible for persisting global settings and may use the module settings methods provided by org.sleuthkit.autopsy.ingest.IngestServices for saving simple properties, or the facilities of classes such as org.sleuthkit.autopsy.coreutils.PlatformUtil and org.sleuthkit.autopsy.coreutils.XMLUtil for more sophisticated approaches.</li>
<li>You are responsible for providing a way for the ingest module to obtain the global settings. For example, the Autopsy core hash look up module comes with a singleton hash databases manager. Users import and create hash databases using the global settings panel. Then they select which hash databases to use for a particular job using the ingest job settings panel. When a module instance runs, it gets the relevant databases from the hash databases manager.</li>
<li>You are responsible for having the ingest job options panel update itself if the global settings change (i.e. if a new item is added that must be listed on the ingest panel).</li>
</ul>
<h1><a class="anchor" id="ingest_modules_api_migration"></a>
Migrating 3.0 Java Ingest Modules to the 3.1 and newer API</h1>
<p>This section is a guide for module developers who wrote modules for the 3.0 API. These API changes occurred so that we could make parallel pipelines of the file-level ingest modules. This section assumes you've read the above description of the new API.</p>
<p>There are three big changes to make in your module:</p><ol type="1">
<li>Modules are no longer singletons. Autopsy will make one of your factory classes and many instances of the ingest modules. As part of the migration to the new classes, your singleton infrastructure will disappear.</li>
<li>You'll need to move the UI/Configuration methods into the factory class and the ingest module methods into their own class. You'll also need to update the APIs for the methods a bit.</li>
<li>You'll need to review your ingest module code for thread safety if you are using any static member variables.</li>
</ol>
<p>We recommend that you:</p><ol type="1">
<li>Create a new factory class and move over the UI panels, configuration code, and standard methods (name, description, version, etc.). You'll probably want the name in the ingest module code, so you should also store the name in a package-wide static member variable.</li>
<li>Get the factory to compile and work. You can do basic testing by running Autopsy and verifying that you see your module and its panels.</li>
<li>Change your old ingest module to implement the new interface and adjust it (see the name changes below). Then update the factory to create it.</li>
<li>Review the ingest module code for thread safety (especially look for static member variables).</li>
</ol>
<p>The following table provides a mapping of the methods of the old abstract classes to the new interfaces:</p>
<table class="doxtable">
<tr>
<th>Old method </th><th>New Method  </th></tr>
<tr>
<td>IngestModuleAbstract.getType() </td><td>N/A </td></tr>
<tr>
<td>IngestModuleAbstract.init() </td><td>IngestModule.startUp() </td></tr>
<tr>
<td>IngestModuleAbstract.getName() </td><td>IngestModuleFactory.getModuleName() </td></tr>
<tr>
<td>IngestModuleAbstract.getDescription() </td><td>IngestModuleFactory.getModuleDescription() </td></tr>
<tr>
<td>IngestModuleAbstract.getVersion() </td><td>IngestModuleFactory.getModuleVersion() </td></tr>
<tr>
<td>IngestModuleAbstract.hasBackgroundJobsRunning </td><td>N/A </td></tr>
<tr>
<td>IngestModuleAbstract.complete() </td><td>IngestModule.shutDown() for file ingest modules; data source ingest modules should do anything they did in complete() at the end of the process() method </td></tr>
<tr>
<td>IngestModuleAbstract.hasAdvancedConfiguration() </td><td>IngestModuleFactory.hasGlobalSettingsPanel() </td></tr>
<tr>
<td>IngestModuleAbstract.getAdvancedConfiguration() </td><td>IngestModuleFactory.getGlobalSettingsPanel() </td></tr>
<tr>
<td>IngestModuleAbstract.saveAdvancedConfiguration() </td><td>IngestModuleGlobalSetttingsPanel.saveSettings() </td></tr>
<tr>
<td>N/A </td><td>IngestModuleFactory.getDefaultIngestJobSettings() </td></tr>
<tr>
<td>IngestModuleAbstract.hasSimpleConfiguration() </td><td>IngestModuleFactory.hasIngestJobSettingsPanel() </td></tr>
<tr>
<td>IngestModuleAbstract.getSimpleConfiguration() </td><td>IngestModuleFactory.getIngestJobSettingsPanel() </td></tr>
<tr>
<td>IngestModuleAbstract.saveSimpleConfiguration() </td><td>N/A </td></tr>
<tr>
<td>N/A </td><td>IngestModuleIngestJobSettingsPanel.getSettings() </td></tr>
<tr>
<td>N/A </td><td>IngestModuleFactory.isDataSourceIngestModuleFactory() </td></tr>
<tr>
<td>N/A </td><td>IngestModuleFactory.createDataSourceIngestModule() </td></tr>
<tr>
<td>N/A </td><td>IngestModuleFactory.isFileIngestModuleFactory() </td></tr>
<tr>
<td>N/A </td><td>IngestModuleFactory.createFileIngestModule() </td></tr>
</table>
<p>Notes:</p><ul>
<li>IngestModuleFactory.getModuleName() should delegate to a static class method that can also be called by ingest module instances.</li>
<li>The IngestJobContext object passed to startUp() can be queried to determine whether the ingest job completed or was cancelled.</li>
<li>The global settings panel (formerly "advanced") for a module must implement IngestModuleGlobalSettingsPanel which extends JPanel. Global settings are those that affect all modules, regardless of ingest job and pipeline.</li>
<li>The per ingest job settings panel (formerly "simple") for a module must implement IngestModuleIngestJobSettingsPanel which extends JPanel. It takes the settings for the current context as a serializable IngestModuleIngestJobSettings object and its getSettings() methods returns a serializable IngestModuleIngestJobSettings object. The IngestModuleIngestJobSettingsPanel.getSettings() method replaces the saveSimpleSettings() method, except that now Autopsy persists the settings in a context-sensitive fashion.</li>
<li>The IngestModuleFactory creation methods replace the getInstance() methods of the former singletons and receive a IngestModuleIngestJobSettings object that should be passed to the constructors of the module instances the factory creates. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
